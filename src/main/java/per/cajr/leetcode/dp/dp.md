# 动态规划问题（Dynamic Programming）

动态规划问题解析：

1. 明确**状态**
2. 明确**选择**
3. 状态转移遵守的关系式，也就是**状态转移方程**
4. **base case** 
5. 消除**「重叠子问题」**优化（备忘录优化，空间压缩）

```java
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

## 股票买卖时机系列问题

股票买卖时机问题是dp里面经典题目，而且复杂，状态多且很难明确。

股票买卖问题都是共通的，只需要把其中最泛化的一道抽出来总结

LeetCode第188题 [买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)：

![image-20220615105849308](https://cajr-news-img.oss-cn-shenzhen.aliyuncs.com/img/image-20220615105849308.png)

第一步找**状态**，这里状态有三个：**天数i、最多交易笔数K以及当前持有股票状态（我们不妨用 1 表示持有，0 表示没有持有）**

第二步**选择**，每天的操作又分为三种选择：**买入（buy）**、**卖出（sell）**以及**无操作（rest）**，这里的还要注意的是不是每天都可以任意选择三种选择的，在`sell`之前必须在`buy`之后，`buy`又必须在`sell`之后，所以`rest`操作还应该分两种状态，一种是`buy`之后的`rest`（持有股票），另一种就是`sell`之后的`rest`（没有持有股票）。还有最多交易笔数`K`的限制，也就是说buy是只能在`k > 0`情况下进行

然后我们用一个三维数组就可以装下这几种状态的全部组合：

```java
dp[i][k][0 or 1] 满足：0 <= i <= n-1, 1 <= k <= K (其中n为天数 K为交易数上限 0和1代表是否持有股票)

for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```

我们可以用自然语言描述出每一个状态的含义，比如说 `dp[3][2][1]` 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易

然后我们最后求的是`dp[n-1][K][0]` 

记住如何解释「状态」，一旦觉得哪里不好理解，把它翻译成自然语言就容易理解了

第三步找**状态转移方程**，完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」

分两种情况：`dp[i][k][0]` 以及`dp[i][k][1]`

找`dp[i][k][0]` 表达式，用我们的话说：第i天 在允许交易笔数k下没有持有股票，这个状态怎么更新来呢；从第一个状态天数看很明显是从昨天更新来的，昨天又有两种可能：

1. 昨天我就没有持有股票，也就是无操作`rest`，而且截止到昨天最多交易数为`k`,今天我依然选择了`rest`无操作，交易数还是k，到手利润和昨天利润一样
2. 昨天我持有股票且截止到昨天最多交易数为`k`，今天我把股票卖出去了，也就是`sell`，所以今天变成没有持有了，没有涉及`buy`,交易数还是k，到手利润昨天利润加上`prices[i]`，

从这两种可能中求最大利润，列出`dp[i][k][0]` 表达式：

```java
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
    		max( 今天选择 rest,        今天选择 sell       )
```

找`dp[i][k][1]` 表达式，也有两种可能：

1. 昨天我没有持有股票，且截止到昨天最多交易数为`k - 1`，今天我选择买入`buy`，所以今天我就持有股票了，最大交易数为`k`， 到手利润会减掉今天的股票价格`prices[i]`
2. 昨天我本就持有股票，且截止到昨天最多交易数为`k`，今天我没有操作，到手利润没有变

从这两种可能中求最大利润，列出`dp[i][k][0]` 表达式：

```java
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][1] - prices[i])
    		max( 今天选择 rest,        今天选择 buy       )
```

这里着重提醒一下，**时刻牢记「状态」的定义**，状态 `k` 的定义并不是「已进行的交易次数」，而是「最大交易次数的上限限制」。如果确定今天进行一次交易，且要保证截至今天最大交易次数上限为 `k`，那么昨天的最大交易次数上限必须是 `k - 1`

至此，状态转移方程就列出来了，还剩base case，也就是最简单的情况，有以下四种情况：

```java
dp[-1][...][0]=0 
    解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。
dp[-1][...][1]=-infinity
    解释：还没开始的时候，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值
dp[...][0][0]=0
     解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。
dp[...][0][1]=-infinity
    解释：没有交易数，是不可能持有股票的。因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值
```

把上面总结下：

```java
//base case
dp[-1][...][0] = dp[...][0][0] = 0;
dp[-1][...][1] = dp[...][0][1] = -infinity;

//状态转移方程
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
```

